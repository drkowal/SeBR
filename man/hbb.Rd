% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helper_funs.R
\name{hbb}
\alias{hbb}
\title{Hierarchical Bayesian bootstrap posterior sampler}
\usage{
hbb(y, groups, alphas = NULL, M = 100)
}
\arguments{
\item{y}{the data from which to infer the group-specific CDFs}

\item{groups}{the group assignment for each element of \code{y}}

\item{alphas}{(optional) vector of concentration parameters corresponding
to the unique levels in \code{groups}}

\item{M}{a positive scaling term to set a default value of \code{alphas} if
it is unspecified (or \code{NULL})}
}
\value{
a list with the following elements:
\itemize{
 \item \code{Fyc}: a list of \code{K} functions where each entry corresponds to a group
 and that group-specific function can evaluate the sampled CDF at any argument(s)
 \item \code{weights_y}: sampled weights from the common (BB) distribution (\code{n}-dimensional)
 \item \code{weights_yc}: sampled weights from each of the \code{K} groups (\code{K x n})
}
}
\description{
Compute one Monte Carlo draw from the hierarchical Bayesian bootstrap (HBB)
posterior distribution of the cumulative distribution function (CDF) for
each group. The group-specific HBB weights are also returned.
}
\details{
Assuming the data \code{y} are independently drawn from unknown,
group-specific distributions, the hierarchical Bayesian bootstrap (HBB) from
Oganisian et al. (\url{https://doi.org/10.1515/ijb-2022-0051}) is a nonparametric model
for each distribution. The HBB includes hierarchical shrinkage across these
groups toward a common distribution (the BB \code{\link{bb}}). The HBB admits
direct Monte Carlo (not MCMC) sampling.

When \code{alphas} is unspecified (or \code{NULL}), we adopt the default from Oganisian et al.
which sets the \code{c}th entry to \code{M*n/nc} where \code{M} is user-specified and
\code{nc} is the number of observations in group \code{c}. Note that \code{alphas}
is the hyperparameter that determines the amount pooling toward the common (BB) distribution.
Here, larger \code{M} (and \code{alphas}) encourages more shrinkage toward a common distribution, while
smaller \code{M} (and \code{alphas}) allows the group-specific distributions to vary more substantially
from each other.
}
\note{
Reference: Oganisian et al. (\url{https://doi.org/10.1515/ijb-2022-0051})
}
\examples{
# Sample size and number of groups:
n = 500
K = 3

# Define the groups, then assign:
ugroups = paste('g', 1:K, sep='') # groups
groups = sample(ugroups, n, replace = TRUE) # assignments

# Simulate the data: iid normal, then add group-specific features
y = rnorm(n = n) # data
for(g in ugroups)
  y[groups==g] = y[groups==g] + 3*rnorm(1) # group-specific

# One draw from the HBB posterior of the CDF:
samp_hbb = hbb(y, groups)

names(samp_hbb) # items returned
Fyc = samp_hbb$Fyc # list of CDFs
class(Fyc) # this is a list
class(Fyc[[1]]) # each element is a function

c = 1 # try: vary in 1:K
Fyc[[c]](0) # some example use (for this one draw)
Fyc[[c]](c(.5, 1.2))

# Plot several draws from the HBB posterior distribution:
ys = seq(min(y), max(y), length.out=1000)
plot(ys, ys, type='n', ylim = c(0,1),
     main = 'Draws from HBB posteriors', xlab = 'y', ylab = 'F_c(y)')
for(s in 1:50){ # some draws

  # BB CDF:
  Fy = bb(y)
  lines(ys, Fy(ys), lwd=3) # plot CDF

  # HBB:
  Fyc = hbb(y, groups, M = 25)$Fyc

  # Plot CDFs by group:
  for(c in 1:K) lines(ys, Fyc[[c]](ys), col=c+1, lwd=3)
}

# For reference, add the ECDFs by group:
for(c in 1:K) lines(ys, ecdf(y[groups==ugroups[c]])(ys), lty=2)

legend('bottomright', c('BB', paste('HBB:', ugroups)), col = 1:(K+1), lwd=3)

}
